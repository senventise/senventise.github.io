{"pages":[{"title":"","text":"Galgame记录已完成: 名字 开始时间 结束时间 出品商 心情 评价 美少女万华镜1 2018.X.X 2018.X.X ωstar 快乐 + 沙耶之歌 2018.X.X 2018.X.X Nitro+ 抑郁+ + 美少女万华镜2 2019.2.11 2019.2.11 ωstar 快乐+ + 美少女万华镜2.5 2019.2.14 2019.2.14 ωstar 社保\\ 惊吓 - 美少女万华镜3 2019.2.15 2019.2.15 ωstar 快乐 + 美少女万华镜4 2019.2.16 2019.2.16 ωstar 抑郁++ + 缘之空 2019.2.17 2019.2.25 Sphere 快乐+ + 千恋万花 2019.2.27 2019.3.2 柚子社 快乐++ + Riddle Joker 2019.3.11 2019.3.13 柚子社 快乐++ + 君与彼女与彼女之恋 2019.3.17 2019.3.18 Nitro+ 抑郁++ + 待完成:Riddle Joker 魔女的夜宴 夏空彼方 秽翼的尤斯蒂娅 千之刃涛、桃花染之皇姬 关于这个页面 p.s.表格可滚动","link":"/galgame/index.html"},{"title":"关于","text":"关于作者目前是一名普通高二学生。 初二电脑被没收，百无聊赖中接触到了 Minecraft pe，开始自己编 js 脚本，第一次接触到了编程，一下子就被吸引了，之后又入了 AIDE 的坑，开始学习 Android 开发和 Java。 初三毕业的暑假学了 Python，自己写的第一个脚本是一个爬虫（爬的是**领域 #滑稽） 高一寒假（2018.1），自己试着装 ArchLinux（第一次就是在实体机上装，头铁），折腾了一个周末，成功装上了，kde 真的是非常漂亮，把我惊艳到了。从此入了 ArchLinux教。 高一暑假，进入了上海交通大学网络空间安全实践工作站学习网络安全，受益匪浅，也对网络安全产生了浓厚的兴趣。 高二寒假（现在），正在学习 Rust 和 Haskell。 关于本站使用hexo搭建，主题是Icarus,图片使用了微博图床，部分大文件放在腾讯云对象存储上，托管于Github Pages. 联系方式邮箱: senventise@gmail.com QQ: MjM3NTc0MTg1OQ==","link":"/about/index.html"}],"posts":[{"title":"记安装 kali 遇到的坑","text":"emmmm因为一些机缘巧合进入了交通大学网络空间安全工作站，既来之则安之，今天在安装kali时遇到了一些问题，遂记之。 问题1：系统安装时出现错误这个问题是在图形引导安装系统时出现的，使用搜索引擎发现是因为在VMwAre分配的空间太小，于是重新安装，分配了20G空间，问题解决。 问题2：没有网络连接编辑虚拟机设置–&gt;网络适配器–&gt;桥接模式,解决。 问题3：安装VMware tools时提示只读文件系统原因：cdrom是只读的，解压时要加上 -C /目录 解压到指定目录。 总结：善用搜索引擎！","link":"/2018/07/09/problems-with-kali-linux-installation/"},{"title":"机器学习笔记-1","text":"监督学习(Surpervised learning)在监督学习中,给定一组数据,我们知道正确的输出结果应该是什么样子,并且知道在输入和输出之间有着一个特定的关系. 回归问题(Regression)通常是预测一个值.eg.预测某个面积的房屋价格 分类问题(Classification)预测一个离散值,试图将输入变量与离散的类别对应起来.eg.预测某个大小的肿瘤是良性还是恶性有时分类问题可能会有多种输出,可能不止两种. 无监督学习(Unsupervised learning)在无监督学习中，我们基本上不知道结果会是什么样子,但我们可以通过聚类的方式从数据中提取一个特殊的结构.在无监督学习中给定的数据是和监督学习中给定的数据是不一样的.在无监督学习中给定的数据没有任何标签.eg.Google News 会自动将网上的新闻分类,例如XX油井发生火灾的分类里面的页面都是互联网上关于这场火灾的报道. 线性回归模型(Linear regression)$$ h_\\theta(x)=\\theta_0+\\theta_1x $$(单变量线性回归) h即为假设(hypothess),是拟合的函数. 代价函数(Cost function)/平方误差函数(Square error function)$$ J(\\theta_0,\\theta_1)=\\frac{1}{2m}\\sum_{i=1}^{m}(h_\\theta(x^i)-y^i)^2 $$","link":"/2018/08/03/ML-01/"},{"title":"第一篇博客！","text":"My first blog here!Written by vim on termux,without Chinese input method support. 5/27/2018 21:58","link":"/2018/05/28/2018-5-28-My-first-blog/"},{"title":"浅谈泛型","text":"什么是泛型？ &emsp;&emsp;泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。参数不可以是原始数据类型 例如: 12345678910111213141516171819202122232425262728293031class Gen&lt;T&gt; { private T ob; //定义泛型成员变量 public Gen(T ob){ this.ob = ob; } public T getOb(){ return ob; } public void setOb(T ob){ this.ob = ob; } public void showType(){ System.out.println(\"T的实际类型是: \" + ob.getClass().getName()); }}public class GenDemo { public static void main(String[] args) { //定义泛型类Gen的一个Integer版本 Gen&lt;Integer&gt; intOb = new Gen&lt;Integer&gt;(88); intOb.showType(); int i = intOb.getOb(); System.out.println(\"value= \" + i); System.out.println(\"----------------------------------\"); //定义泛型类Gen的一个String版本 Gen&lt;String&gt; strOb = new Gen&lt;String&gt;(\"Hello Gen!\"); strOb.showType(); String s = strOb.getOb(); System.out.println(\"value= \" + s); }} 泛型类 泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。 e.g.1234567891011121314//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型//在实例化泛型类时，必须指定T的具体类型public class Generic&lt;T&gt;{//key这个成员变量的类型为T,T的类型由外部指定 private T key; public Generic(T key) { //泛型构造方法形参key的类型也为T，T的类型由外部指定 this.key = key; } public T getKey(){ //泛型方法getKey的返回值类型为T，T的类型由外部指定 return key; }} 泛型方法泛型方法，是在调用方法的时候指明泛型的具体类型。e.g.12345678//定义泛型方法public &lt;T&gt; T getObject(Class&lt;T&gt; c){ T t = c.newInstance(); return t;Generic generic = new Generic();//调用泛型方法Object obj=generic.getObject(Class.forName(\"com.test.test\")) &emsp;&emsp;说明一下，定义泛型方法时，必须在返回值前边加一个，来声明这是一个泛型方法，持有一个泛型T，然后才可以用泛型T作为方法的返回值. &emsp;&emsp;Class的作用就是指明泛型的具体类型，而Class类型的变量c，可以用来创建泛型类的对象。 &emsp;&emsp;为什么要用变量c来创建对象呢？既然是泛型方法，就代表着我们不知道具体的类型是什么，也不知道构造方法如何，因此没有办法去new一个对象，但可以利用变量c的newInstance方法去创建对象，也就是利用反射创建对象。 &emsp;&emsp;泛型方法要求的参数是Class类型，而Class.forName()方法的返回值也是Class，因此可以用Class.forName()作为参数。其中，forName()方法中的参数是何种类型，返回的Class就是何种类型。在本例中，forName()方法中传入的是User类的完整路径，因此返回的是Class类型的对象，因此调用泛型方法时，变量c的类型就是Class，因此泛型方法中的泛型T就被指明为User，因此变量obj的类型为User。 &emsp;&emsp;当然，泛型方法不是仅仅可以有一个参数Class，可以根据需要添加其他参数。 &emsp;&emsp;为什么要使用泛型方法呢？因为泛型类要在实例化的时候就指明类型，如果想换一种类型，不得不重新new一次，可能不够灵活；而泛型方法可以在调用的时候指明类型，更加灵活。 文中部分内容出处","link":"/2018/06/01/2018-6-1-talking-about-the-generic/"},{"title":"HP39gII 死机修复","text":"HP39gII 貌似 bug 不少，已经死机了好几次了，而且死机以后未保存的数据会丢失，很烦，前两天在编程玩的时候又一次死机了…而且死机就以后打不开了，卡在 HP logo 的开机界面，百度了一下，貌似只能重刷固件，但是连接工具打不开… 万幸用万能的谷歌找到了答案：在开机时按住删除键(Hold down the backspace key on boot.)，成功开机。 注意，此举将格式化计算器。 出处 附上 39gII 模拟器与连接工具：链接","link":"/2019/01/15/HP39gII-死机修复/"},{"title":"解决archlinux下无法打开atom终端的问题","text":"某次滚动更新以后忽然发现 Atom 的终端不能用了（platformio-atom-ide-terminal），到 issues 里翻了一下，貌似出现这个问题的都是 Manjaro/Arch 用户，解决方法如下： 12$ cd ~/.atom/packages/platformio-ide-terminal$ vim lib/process.coffee 将第一行的 pty = require 'pty.js' 改为 pty = require 'node-pty-prebuilt' ​ 1$ vim package.json 添加依赖：&quot;node-pty-prebuilt&quot;: &quot;^0.7.6&quot; 12$ npm install node-pyt-prebuilt --save $ apm rebuild 然后重启 atom，ctrl+`成功打开。 出处在此","link":"/2019/01/19/解决archlinux下无法打开atom终端问题/"},{"title":"archlinux滚挂","text":"昨天晚上滚动更新了一次，今天早上重启电脑发现挂了……这是第一次滚挂，有点兴奋（#滑稽） 输出如下： 123456Warning:/lib/modules/4.20.3-arch1-1-ARCH/modules.devname not found - ignoringstarting version 240ERROR: device UUID=xxxxxxx not found.Skipping fsck.mount: /new_root: Can&apos;t find UUID=xxxxxxx.You are now being dropped into an emergency shell.sh: can&apos;t access tty; job control turned off 提示进入了 emergency shell ，但是键盘无法输入， google 了一下，找到了解决方法： 进入 livecd 挂载相应分区： 12mount /dev/sha* /mntmount /dev/sha* /mnt/boot chroot: 1arch-chroot /mnt 更新系统： 1pacman -Syu 退出 chroot： 1exit 更新 grub 配置： 1grub-mkconfig -o /mnt/boot/grub/grub.cfg 取消挂载并重启（记得在BIOS里把启动顺序改回来）： 123umount /mnt/bootumount /mntreboot ​ 出处","link":"/2019/01/20/archlinux滚挂/"},{"title":"新建了一个Galgame记录页面","text":"本来对 Galgame 无感，只玩过《沙耶之歌》和《美少女万华镜1》，寒假太无聊，就把万华镜1重新推了一遍，然后一发不可收拾…甚至有那么一点学日语啃生肉的打算… 最近硬盘有点装不下了，整理了一下，把存档都保存了下来，本体删掉了，忽然有点舍不得，就想着把推过的 Galgame整理一下(主要是根据存档的时间来判断，毕竟挺久了，有点记不起来) 本来是记在 Onenote 上的，但是编辑起来实在难受，就想着用 Markdown 试试，所以干脆扔这里来，反正也没人看💔 链接在此","link":"/2019/03/10/新建了一个Galgame记录页面/"},{"title":"galgame补全计划","text":"最近推完了一些 galgame,颇有感触,就想着写下来,也算是给以后留个回忆.然而真当要动笔才发现自己的笔力之薄弱,写得磕磕绊绊,句子也乱七八糟,这才发现自己已经退步得不成样子了.于是这个 Galgame补全计划诞生了,计划的内容只有一个:把我推过的 Galgame 整理一遍,把当时的感想写下来,权当练笔了. btw,fcitx自带的小鹤双拼好难受,完全比不了手机上的 Google拼音输入法 啊…","link":"/2019/03/22/galgame补全计划/"},{"title":"君与彼女与彼女之恋","text":"啊啊一周目凭是感觉来的,在天台上选择了阻止葵,因为我怕葵改变世界会付出代价,处于对葵的喜爱就选择了阻止,没想到打出了最无语的结局:美雪成为了明星,而男主孤独终老.这结局虽然是最合理的,但是我想推葵啊!于是我选择了开始二周目,走入了不归路. 二周目学乖了,选择了不阻止,顺利地进入了美雪线(就是不给我机会直接进葵线…强行让我花心,强行让我BE,真是坏滴很). 三周目轻松进入葵线,当时我完全没有意识到在后面等着我的是什么…一开始是很寻常的套路,但是当男主躲在家门口看到葵在向神明大人忏悔我就知道事情不对,出于侥幸心理我还是坚持看了下去,但当一件件葵出轨的线索摆在我眼前,真的是心如死灰,可笑的是我还妄想后面可能会有洗白,然而真相来的太快,当葵说出原因时我感受到了深深的恶意,喜闻乐见的ntr成了!高兴得我手撕小春的心都有了,恨不得把他狗头打爆,后面那段3p情节更是不能忍,简直是丧心病狂,瞬间感觉手撕他可能已经无法满足我了,说实话我完全无法理解这段情节,没有ntr会死吗?就跟沙耶之歌一样,毫无意义的ntr,除了让玩家骂娘以外没有任何用处,难道就因为美雪才是亲生的吗?葵是后妈养的不成? 看着这封面,我感到一阵讽刺,选择了 Quit,实在没有心情再玩下去了. 未完待续……","link":"/2019/03/22/君与彼女与彼女之恋/"}],"tags":[{"name":"网络安全","slug":"CyberSecurity","link":"/tags/CyberSecurity/"},{"name":"机器学习","slug":"machine-learning","link":"/tags/machine-learning/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"ArchLinux","slug":"ArchLinux","link":"/tags/ArchLinux/"},{"name":"Galgame","slug":"Galgame","link":"/tags/Galgame/"}],"categories":[{"name":"技术","slug":"tech","link":"/categories/tech/"},{"name":"生活","slug":"life","link":"/categories/life/"},{"name":"杂谈","slug":"others","link":"/categories/others/"},{"name":"评价","slug":"review","link":"/categories/review/"}]}