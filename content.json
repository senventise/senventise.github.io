{"pages":[{"title":"关于","text":"页面施工中……","link":"/about/index.html"}],"posts":[{"title":"记安装 kali 遇到的坑","text":"emmmm因为一些机缘巧合进入了交通大学网络空间安全工作站，既来之则安之，今天在安装kali时遇到了一些问题，遂记之。 问题1：系统安装时出现错误这个问题是在图形引导安装系统时出现的，使用搜索引擎发现是因为在VMwAre分配的空间太小，于是重新安装，分配了20G空间，问题解决。 问题2：没有网络连接编辑虚拟机设置–&gt;网络适配器–&gt;桥接模式,解决。 问题3：安装VMware tools时提示只读文件系统原因：cdrom是只读的，解压时要加上 -C /目录 解压到指定目录。 总结：善用搜索引擎！","link":"/2018/07/09/problems-with-kali-linux-installation/"},{"title":"机器学习笔记-1","text":"监督学习(Surpervised learning)在监督学习中,给定一组数据,我们知道正确的输出结果应该是什么样子,并且知道在输入和输出之间有着一个特定的关系. 回归问题(Regression)通常是预测一个值.eg.预测某个面积的房屋价格 分类问题(Classification)预测一个离散值,试图将输入变量与离散的类别对应起来.eg.预测某个大小的肿瘤是良性还是恶性有时分类问题可能会有多种输出,可能不止两种. 无监督学习(Unsupervised learning)在无监督学习中，我们基本上不知道结果会是什么样子,但我们可以通过聚类的方式从数据中提取一个特殊的结构.在无监督学习中给定的数据是和监督学习中给定的数据是不一样的.在无监督学习中给定的数据没有任何标签.eg.Google News 会自动将网上的新闻分类,例如XX油井发生火灾的分类里面的页面都是互联网上关于这场火灾的报道. 线性回归模型(Linear regression)$$ h_\\theta(x)=\\theta_0+\\theta_1x $$(单变量线性回归) h即为假设(hypothess),是拟合的函数. 代价函数(Cost function)/平方误差函数(Square error function)$$ J(\\theta_0,\\theta_1)=\\frac{1}{2m}\\sum^{m}{i=1}(h\\theta(x^i)-y^i)^2 $$","link":"/2018/08/03/ML-01/"},{"title":"第一篇博客！","text":"My first blog here!Written by vim on termux,without Chinese input method support. 5/27/2018 21:58","link":"/2018/05/28/2018-5-28-My-first-blog/"},{"title":"浅谈泛型","text":"什么是泛型？ &emsp;&emsp;泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。参数不可以是原始数据类型 例如:12345678910111213141516171819202122232425262728293031class Gen&lt;T&gt; { private T ob; //定义泛型成员变量 public Gen(T ob){ this.ob = ob; } public T getOb(){ return ob; } public void setOb(T ob){ this.ob = ob; } public void showType(){ System.out.println(\"T的实际类型是: \" + ob.getClass().getName()); }}public class GenDemo { public static void main(String[] args) { //定义泛型类Gen的一个Integer版本 Gen&lt;Integer&gt; intOb = new Gen&lt;Integer&gt;(88); intOb.showType(); int i = intOb.getOb(); System.out.println(\"value= \" + i); System.out.println(\"----------------------------------\"); //定义泛型类Gen的一个String版本 Gen&lt;String&gt; strOb = new Gen&lt;String&gt;(\"Hello Gen!\"); strOb.showType(); String s = strOb.getOb(); System.out.println(\"value= \" + s); }} 泛型类 泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。 e.g.1234567891011121314//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型//在实例化泛型类时，必须指定T的具体类型public class Generic&lt;T&gt;{//key这个成员变量的类型为T,T的类型由外部指定 private T key; public Generic(T key) { //泛型构造方法形参key的类型也为T，T的类型由外部指定 this.key = key; } public T getKey(){ //泛型方法getKey的返回值类型为T，T的类型由外部指定 return key; }} 泛型方法泛型方法，是在调用方法的时候指明泛型的具体类型。e.g.12345678//定义泛型方法public &lt;T&gt; T getObject(Class&lt;T&gt; c){ T t = c.newInstance(); return t;Generic generic = new Generic();//调用泛型方法Object obj=generic.getObject(Class.forName(\"com.test.test\")) &emsp;&emsp;说明一下，定义泛型方法时，必须在返回值前边加一个，来声明这是一个泛型方法，持有一个泛型T，然后才可以用泛型T作为方法的返回值. &emsp;&emsp;Class的作用就是指明泛型的具体类型，而Class类型的变量c，可以用来创建泛型类的对象。 &emsp;&emsp;为什么要用变量c来创建对象呢？既然是泛型方法，就代表着我们不知道具体的类型是什么，也不知道构造方法如何，因此没有办法去new一个对象，但可以利用变量c的newInstance方法去创建对象，也就是利用反射创建对象。 &emsp;&emsp;泛型方法要求的参数是Class类型，而Class.forName()方法的返回值也是Class，因此可以用Class.forName()作为参数。其中，forName()方法中的参数是何种类型，返回的Class就是何种类型。在本例中，forName()方法中传入的是User类的完整路径，因此返回的是Class类型的对象，因此调用泛型方法时，变量c的类型就是Class，因此泛型方法中的泛型T就被指明为User，因此变量obj的类型为User。 &emsp;&emsp;当然，泛型方法不是仅仅可以有一个参数Class，可以根据需要添加其他参数。 &emsp;&emsp;为什么要使用泛型方法呢？因为泛型类要在实例化的时候就指明类型，如果想换一种类型，不得不重新new一次，可能不够灵活；而泛型方法可以在调用的时候指明类型，更加灵活。 文中部分内容出处","link":"/2018/06/01/2018-6-1-talking-about-the-generic/"},{"title":"HP39gII 死机修复","text":"HP39gII 貌似 bug 不少，已经死机了好几次了，而且死机以后未保存的数据会丢失，很烦，前两天在编程玩的时候又一次死机了…而且死机就以后打不开了，卡在 HP logo 的开机界面，百度了一下，貌似只能重刷固件，但是连接工具打不开…万幸用万能的谷歌找到了答案：在开机时按住删除键(Hold down the backspace key on boot.)，成功开机。 注意，此举将格式化计算器。 出处 附上 39gII 模拟器与连接工具：链接","link":"/2019/01/15/HP39gII-死机修复/"}],"tags":[{"name":"网络安全","slug":"CyberSecurity","link":"/tags/CyberSecurity/"},{"name":"Java","slug":"Java","link":"/tags/Java/"}],"categories":[{"name":"技术","slug":"tech","link":"/categories/tech/"},{"name":"生活","slug":"life","link":"/categories/life/"}]}